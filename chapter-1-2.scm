#| 1.2 Procedures and the Processes They Generate #|

#|Exercise 1.9: Each of the following two procedures defines a method
for adding two positive integers in terms of the procedures inc,
which increments its argument by 1, and dec, which decrements its argument by 1. |#
(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))

#|Using the substitution model, illustrate the process generated by each procedure
in evaluating (+ 4 5). Are these processes iterative or recursive? |#

;; Solution:

;;1. Recursive process:

(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9

;;This process is recursive because it computes through
;;recursive calls until it reaches the base case (when `a` becomes 0).

;;2. Iterative process:

(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9

#|This process is iterative because it computes in a loop, using
intermediate values (`a` decreases from 4 to 0, while `b` increases from 5 to 9).

Thus, the first procedure uses recursion to compute the sum,
while the second procedure uses iteration. |#


#|Exercise 1.10: The following procedure computes a mathematical function
called Ackermann’s function.|#
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))

;;What are the values of the following expressions?
(A 1 10)
(A 2 4)
(A 3 3)

;;Consider the following procedures, where A is the procedure defined above:

(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))

#| Give concise mathematical definitions for the functions computed by
the procedures f, g, and h for positive integer values of n.
For example, (k n) computes 5n^2.|#

;; Solution:
;;Computing (A 1 10):
(A 1 10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8)))
…
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
…
1024

;;Computing (A 2 4):
(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (A 0 (A 1 1))))
(A 1 (A 1 (* 2 (A 1 1))))
(A 1 (A 1 (* 2 2)))
(A 1 (A 1 4))
…
(A 1 16)
…
2 ^ 16 = 65536

;;Computing (A 3 3):
(A 3 3)
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
(A 2 (A 1 (A 2 1)))
(A 2 (A 1 2))
(A 2 4)
…
65536

;;Consider the following procedure:
(define (f n) (A 0 n))

;;Based on the definition of procedure A, substitute x = 0, y = n:
(define (A 0 n)
  (cond ((= n 0) 0)
        ((= 0 0) (* 2 n))
        ((= n 1) 2)
        (else (A (- 0 1) (A 0 (- n 1))))))

;;This procedure simplifies to:
(define (A 0 n)
  (* 2 n))

;;Thus, the procedure f can be written as: f(n) = 2n

;;Consider the procedure g:
(define (g n) (A 1 n))

;;We will proceed similarly. Substitute values:
(define (A 1 n)
  (cond ((= n 0) 0)
        ((= 1 0) (* 2 y))
        ((= n 1) 2)
        (else (A (- 1 1) (A 1 (- n 1))))))

;;Simplify:
(define (A 1 n)
  (cond ((= n 0) 0)
        ((= n 1) 2)
        (else (A 0 (A 1 (- n 1))))))

;;Considering the formula for f(n):
(define (A 1 n)
  (cond ((= n 0) 0)
        ((= n 1) 2)
        (else (* 2 (A 1 (- n 1))))))

;;The procedure can be written recursively: g(n) = 2 * g(n - 1) (except when n = 0).
;;Thus, the procedure g can be written as: g(n) = 0, if n = 0; g(n) = 2^n

;;Consider the procedure h:
(define (h n) (A 2 n))

;;Substitute and simplify:
(define (A 2 n)
  (cond ((= n 0) 0)
        ((= n 1) 2)
        (else (A 1 (A 2 (- n 1))))))

#|Considering the formula for g(n), the function can be written recursively
(again, except when n = 0): h(n) = 2^(h(n-1)). Thus, the procedure h can be
written as: h(n) = 0, if n = 0; h(n) = 2^(2^(2^…2^2)…), that is, 2 raised to
the power of 2, raised to the power of 2, and so on (n - 1) times.|#


#| Exercise 1.11: A function f is defined by the rule that 
f(n) = n, if n < 3, and f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3), if n ≥ 3.
Write a procedure that computes f by means of a recursive
process. Write a procedure that computes f by means of an iterative process. |#

;; Solution:
;;recursive process ver. 1
(define (f n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        ((= n 2) 2)
        (else (+ (f (- n 1))
                 (* 2 (f (- n 2)))
                 (* 3 (f (- n 3)))))))

;;ver. 2
(define (f n)
  (if (< n 3)
      n
      (+ (f (- n 1))
                 (* 2 (f (- n 2)))
                 (* 3 (f (- n 3))))))

;;iterative process
(define (f-iter n)
  (f-i 2 1 0 n))

(define (f-i a b c count)
  (if (= count 0)
      c
      (f-i (+ (* 3 c) (* 2 b) a)
           a
           b
           (- count 1))))


#| Exercise 1.12: The following pattern of numbers is called Pascal’s triangle.
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
. . .
The numbers at the edge of the triangle are all 1, and each number inside
the triangle is the sum of the two numbers above it. Write a procedure that
computes elements of Pascal’s triangle by means of a recursive process. |#

;; Solution:
(define (solution row n)
  (cond ((= row 1) 1)
        ((= n 1) 1)
        ((= n row) 1)
        (else (+ (solution (- row 1) (- n 1))
                 (solution (- row 1) n)))))


#|Exercise 1.13: Prove that Fib(n) is the closest integer to φ^n / √5,
where φ = (1 + √5) / 2. Hint: Let ψ = (1 − √5) / 2. Use induction
and the definition of the Fibonacci numbers (see Section 1.2.2) to prove
that Fib(n) = (φ^n − ψ^n) / √5.|#

#|Solution:
1. Base Case
For n = 0:  
Fib(0) = 0  
(φ^0 - ψ^0) / √5 = (1 - 1) / √5 = 0  

For n = 1:  
Fib(1) = 1  
(φ^1 - ψ^1) / √5 = (φ - ψ) / √5 =
= ((1 + √5)/2 - (1 - √5)/2) / √5 = √5 / √5 = 1  

2. Induction Hypothesis
Assume the formula holds for n = k and n = k+1:  
Fib(k) = (φ^k - ψ^k) / √5  
Fib(k+1) = (φ^(k+1) - ψ^(k+1)) / √5  

3. Induction Step
Show that the formula holds for n = k+2:  
Fib(k+2) = Fib(k+1) + Fib(k)  
Fib(k+2) = (φ^(k+1) - ψ^(k+1)) / √5 + (φ^k - ψ^k) / √5  
Fib(k+2) = (φ^(k+1) + φ^k - (ψ^(k+1) + ψ^k)) / √5  

Proving the properties of φ and ψ:
φ = (1 + √5) / 2
φ^2 = ((1 + √5) / 2)^2 = (1 + 2√5 + 5) / 4 =
= (6 + 2√5) / 4 = (3 + √5) / 2
φ + 1 = (1 + √5) / 2 + 1 = (3 + √5) / 2
Thus, φ^2 = φ + 1.  

Similarly for ψ:
Thus, ψ^2 = ψ + 1.  

Using these properties:  
φ^(k+2) = φ^(k+1) * φ = (φ + 1) * φ^k = φ^(k+1) + φ^k  
ψ^(k+2) = ψ^(k+1) * ψ = (ψ + 1) * ψ^k = ψ^(k+1) + ψ^k  

Thus,  
Fib(k+2) = (φ^(k+2) - ψ^(k+2)) / √5  

4. Conclusion
By induction, the formula Fib(n) = (φ^n - ψ^n) / √5 holds for all n.
Since |ψ| < 1, ψ^n approaches zero as n increases,
therefore Fib(n) approximates φ^n / √5, proving that Fib(n)
is the nearest integer to φ^n / √5.|#


#|Exercise 1.14: Draw the tree illustrating the process generated
by the count-change procedure of Section 1.2.2 in making change
for 11 cents. What are the orders of growth of the space
and number of steps used by this process as he amount to be changed increases?|#

;; Solution:
;; Simplified tree illustrating the process generated by the
;; count-change procedure from section 1.2.2 for exchanging 11 cents.

(cc 11 5)
├── (cc 11 4)
│   ├── (cc 11 3)
│   │   ├── (cc 11 2)
│   │   │   ├── (cc 11 1)
│   │   │   │   └── ...
│   │   │   │             ├── (cc 1 0) -> 0
│   │   │   │             └── (cc 0 1) -> 1
│   │   │   └── (cc 6 2)
│   │   │       ├── (cc 6 1)
│   │   │       │   └── ...
│   │   │       │             ├── (cc 1 0) -> 0
│   │   │       │             └── (cc 0 1) -> 1
│   │   │       └── (cc 1 2)
│   │   │           ├── (cc 1 1)
│   │   │           │   └── ...
│   │   │           │             ├── (cc 1 0) -> 0
│   │   │           │             └── (cc 0 1) -> 1
│   │   │           └── (cc -4 2) -> 0
│   │   └── (cc 1 3)
│   │       └── ...
│   │                 ├── (cc 1 0) -> 0
│   │                 └── (cc 0 1) -> 1
│   └── (cc -14 4) -> 0
└── (cc -39 5) -> 0

#| Growth Orders of Space

Since this is a recursive process, the order of
growth of space should be proportional to the depth of the tree.
Let's consider the growth orders for different numbers of coins
and try to understand the pattern. The longest series of calls
will occur when changing the amount n using only coins worth 1 cent.
The order of growth of space for (cc) will be R(n, 1) = Θ(n).
This can be seen in the example: |#

(cc n 1)
├── (cc n-1 1)
│   ├── (cc n-2 1)
│   │   └── ...
│   │             ├── (cc 0 1) -> 1
│   │             └── (cc 1 0) -> 0
│   └── (cc n-1 0) -> 0
└── (cc n 0) -> 0

#| The process is linear, and each node splits into two sub-steps,
but only the node with (cc n 1) will be deeper. All (cc n 0) are leaves of this tree.

When increasing the number of coins to two, it is no longer
a linear array but a two-dimensional one, as can be seen in the example: |#

(cc n 2)
├── (cc n 1)
│   └── ...
│             ├── (cc 0 1) -> 1
│             └── (cc 1 0) -> 0
├── (cc n-5 2)
│   └── ...
│             ├── (cc 0 1) -> 1
│             └── (cc 1 0) -> 0
├── (cc n-10 2)
│   └── ...
│             ├── (cc 0 1) -> 1
│             └── (cc 1 0) -> 0
├── ...
└── (cc neg-num 2) -> 0

#| The number of calls to (cc n 2) will equal the number of times 5 cents
can be subtracted from n plus one. And for each such call (amount),
we call the variant with only one coin. Thus, the growth will
already be quadratic R(n, 2) = Θ(n²).

Similarly, by increasing the number of coins, it can be seen that
for the case of five coins the answer will Θ(n^5), since each type of coin
adds a new degree to the growth.

Generalizing to the case of k coins, it can be proven that:
R(n, k) ≤ k * R(n-1, k) + O(1).|#


#|Exercise 1.15: The sine of an angle (specified in radians) can be
computed by making use of the approximation sin x ≈ x if x is
sufficiently small, and the trigonometric identity
sin(x) = 3sin(x / 3) − 4sin³(x / 3)
to reduce the size of the argument of sin. (For purposes of this exercise
an angle is considered “sufficiently small” if its magnitude is not
greater than 0.1 radians.) These ideas are incorporated in the
following procedures: |#

(define (cube x) (* x x x))

(define (p x) (- (* 3 x)
                 (* 4 (cube x))))

(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))

#| a. How many times is the procedure p applied when
(sine 12.15) is evaluated?

b. What is the order of growth in space and number of
steps (as a function of a) used by the process generated
by the sine procedure when (sine a) is evaluated?
|#

#|Solution:

a. The `sine` procedure divides the angle by 3 until it
becomes less than or equal to 0.1 radians. This occurs when:

12.15 / 3^n ≤ 0.1

Solving for n:

121.5 ≤ 3^n
n ≥ log(121.5) ≈ 5

The `p` procedure is called 5 times.

b. Orders of growth in terms of the number of steps
and memory used (as a function of a) for the process
generated by the `sine` procedure when computing `(sine a)`

The number of steps and memory used are proportional
to the depth of recursion, which is equal to log(a).

- Number of steps: Θ(log(a))
- Memory used: Θ(log(a)) |#


#|Exercise 1.16: Design a procedure that evolves an iterative
exponentiation process that uses successive squaring
and uses a logarithmic number of steps, as does fast-expt.
(Hint: Using the observation that ((bⁿ୵²)² = (b²)ⁿ୵², keep,
along with the exponent n and the base b, an additional
state variable a, and define the state transformation in such
a way that the product abⁿ is unchanged from state to state.
At the beginning of the process a is taken to be 1, and the
answer is given by the value of a at the end of the process.
In general, the technique of defining an invariant quantity
that remains unchanged from state to state is a powerful
way to think about the design of iterative algorithms.) |#

;; Solution:
(define (solution b n)
  (expt-iter 1 b n))

(define (expt-iter a b n)
  (cond ((= n 0) a)
        ((even? n) (expt-iter a (* b b) (/ n 2)))
        (else (expt-iter (* a b) b (- n 1)))))

(define (even? n)
  (= (remainder n 2) 0))


#|Exercise 1.17: The exponentiation algorithms in this section are
based on performing exponentiation by means of repeated multiplication.
In a similar way, one can perform integer multiplication by means of
repeated addition. The following multiplication procedure (in which
it is assumed that our language can only add, not multiply) is
analogous to the expt procedure: |#

(define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))

#| This algorithm takes a number of steps that is linear in b. Now
suppose we include, together with addition, operations double, which
doubles an integer, and halve, which divides an (even) integer by 2.
Using these, design a multiplication procedure analogous to fast-expt 
that uses a logarithmic number of steps.|#

;; Solution:
(define (fast-mul a b)
  (cond ((= b 0) 0)
        ((even? b) (double (fast-mul a (halve b))))
        (else (+ a (fast-mul a (- b 1))))))

(define (double x) (+ x x))

(define (halve x) (/ x 2))

;; halve 2nd version (if division is not available):
(define (halve x)
  (define (halve-i y z)
    (if (= y (double z))
        z
        (halve-i y (- z 1))))
  (halve-i x x))

#|Exercise 1.18: Using the results of Exercise 1.16 and Exercise 1.17,
devise a procedure that generates an iterative process for multiplying 
two integers in terms of adding, doubling, and halving and uses a
logarithmic number of steps.|#

;; Solution:
(define (double x) (+ x x))

(define (halve x) (/ x 2))

(define (mul-iter a b)
  (iter 0 a b))

(define (iter res a b)
  (cond ((= b 0) res)
        ((even? b) (iter res (double a) (halve b)))
        (else (iter (+ res a) a (- b 1)))))


#|Exercise 1.19: There is a clever algorithm for computing
the Fibonacci numbers in a logarithmic number of steps.
Recall the transformation of the state variables a and b in
the fib-iter process of Section 1.2.2: a ← a + b and b ← a.
Call this transformation T, and observe that applying T
over and over again n times, starting with 1 and 0, produces
the pair Fib(n + 1) and Fib(n). In other words, the Fibonacci
numbers are produced by applying Tn, the nth power of the
transformation T, starting with the pair (1, 0). Now consider
T to be the special case of p = 0 and q = 1 in a family of
transformations Tpq, where Tpq transforms the pair (a, b)
according to a ← bq + aq + ap and b ← bp + aq. Show that
if we apply such a transformation Tpq twice, the effect
is the same as using a single transformation Tp′q′ of the
same form, and compute p′and q′in terms of p and q. This
gives us an explicit way to square these transformations,
and thus we can compute Tn using successive squaring, as
in the fast-expt procedure. Put this all together to complete
the following procedure, which runs in a logarithmic number
of steps.|#

;; Solution:
(define (fib n)
  (fib-iter 1 0 0 1 n))
(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   (+ (* p p) (* q q))
                   (+ (* 2 p q) (* q q))
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))


#|Exercise 1.20: The process that a procedure generates is
of course dependent on the rules used by the interpreter.
As an example, consider the iterative gcd procedure given
above. Suppose we were to interpret this procedure using
normal-order evaluation, as discussed in Section 1.1.5. (The
normal-order-evaluation rule for if is described in Exercise
1.5.) Using the substitution method (for normal order),
illustrate the process generated in evaluating (gcd 206 40) and
indicate the remainder operations that are actually performed.
How many remainder operations are actually performed in the
normal-order evaluation of (gcd 206 40)?
In the applicative-order evaluation?|#

;; Solution:
;; Normal Order Evaluation

;; When using an interpreter that employs normal order evaluation,
;; the interpreter will "fully expand and then reduce."

(gcd 206 40) ;; expands to:

(if (= 40 0)
    206
    (gcd 40 (remainder 206 40)))

;; After evaluating the `if` expression:

(gcd 40 (remainder 206 40)))

;; Which expands to:

(if (= (remainder 206 40) 0)
    40
    (gcd (remainder 206 40)
         (remainder 40 (remainder 206 40))))

;; During the next evaluation of `if`, the `remainder` will be
;; executed for the 1 time ((remainder 206 40) = 6):

(if (= 6 0)
    40
    (gcd (remainder 206 40)
         (remainder 40 (remainder 206 40))))

;; Then:

(gcd (remainder 206 40)
     (remainder 40 (remainder 206 40)))

;; Which expands to:

(if (= (remainder 40 (remainder 206 40)) 0)
    (remainder 206 40)
    (gcd (remainder 40 (remainder 206 40))
         (remainder (remainder 206 40)
                    (remainder 40 (remainder 206 40)))))

;; At this step, evaluating `if` requires computing `remainder`
;; 2 times ((remainder 40 (remainder 206 40)) = (remainder 40 6) = 4):

(if (= 4 0)
    (remainder 206 40)
    (gcd (remainder 40 (remainder 206 40))
         (remainder (remainder 206 40)
                    (remainder 40 (remainder 206 40)))))

;; Then:

(gcd (remainder 40 (remainder 206 40))
     (remainder (remainder 206 40)
                (remainder 40 (remainder 206 40))))

;; Which expands to:

(if (= (remainder (remainder 206 40)
                  (remainder 40 (remainder 206 40)))
       0)
    (remainder 40 (remainder 206 40))
    (gcd (remainder (remainder 206 40)
                    (remainder 40 (remainder 206 40)))
         (remainder (remainder 40 (remainder 206 40))
                    (remainder (remainder 206 40)
                               (remainder 40 (remainder 206 40)))))

;; At this step, evaluating `if` requires computing
;; `remainder` 4 times ((remainder (remainder 206 40)
;;                                 (remainder 40 (remainder 206 40))) =
;;                                                            = … = 2):

(if (= 2 0)
    (remainder 40 (remainder 206 40))
    (gcd (remainder (remainder 206 40)
                    (remainder 40 (remainder 206 40)))
         (remainder (remainder 40 (remainder 206 40))
                    (remainder (remainder 206 40)
                               (remainder 40 (remainder 206 40))))))

;; Then:

(gcd (remainder (remainder 206 40)
                (remainder 40 (remainder 206 40)))
     (remainder (remainder 40 (remainder 206 40))
                (remainder (remainder 206 40)
                           (remainder 40 (remainder 206 40)))))

;; Which expands to:

(if (= (remainder (remainder 40 (remainder 206 40))
                  (remainder (remainder 206 40)
                             (remainder 40 (remainder 206 40))))
       0)
    (remainder (remainder 206 40)
               (remainder 40 (remainder 206 40)))
    (gcd (remainder (remainder 40 (remainder 206 40))
                    (remainder (remainder 206 40)
                               (remainder 40 (remainder 206 40))))
         (remainder (remainder (remainder 40 (remainder 206 40))
                               (remainder (remainder 206 40)
                                          (remainder 40 (remainder 206 40)))))))

;; At this step, evaluating `if` requires computing `remainder` 7 times:

(if (= 0 0)
    (remainder (remainder 206 40)
               (remainder 40 (remainder 206 40)))
    (gcd (remainder (remainder 40 (remainder 206 40))
                    (remainder (remainder 206 40)
                               (remainder 40 (remainder 206 40))))
         (remainder (remainder (remainder 40 (remainder 206 40))
                               (remainder (remainder 206 40)
                                          (remainder 40 (remainder 206 40)))))))

;; To get the final result, `remainder` needs to be
;; computed 4 additional times:

(remainder (remainder 206 40)
           (remainder 40 (remainder 206 40)))

2

;; Using normal-order evaluation, `remainder`
;; is called 1 + 2 + 4 + 7 + 4 = 18 times.


;; Applicative-order evaluation

;; An interpreter that uses applicative-order evaluation will
;; “evaluate the arguments and then apply”.

(gcd 206 40)

(if (= 40 0)
    206
    (gcd 40 (remainder 206 40)))

(gcd 40 6)

(if (= 6 0)
    40
    (gcd 6 (remainder 40 6)))

(gcd 6 4)

(if (= 4 0)
    6
    (gcd 4 (remainder 6 4)))

(gcd 4 2)

(if (= 2 0)
    4
    (gcd 2 (remainder 4 2)))

(gcd 2 0)

(if (= 0 0)
    2
    (gcd 0 (remainder 2 0)))

2

;; Using applicative-order evaluation, `remainder`
;; is called 4 times.


#|Exercise 1.21: Use the smallest-divisor procedure to find
the smallest divisor of each of the following numbers: 199, 1999, 19999.|#

;; Solution:
(define (smallest-divisor n)
  (find-divisor n 2))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))

(define (divides? a b)
  (= (remainder b a) 0))

(smallest-divisor 199)
;; > 199
;; this number is prime

(smallest-divisor 1999)
;; > 1999
;; this number is prime

(smallest-divisor 19999)
;; > 7
;; this number is not prime
;; 19999 = 7*2857


#|Exercise 1.22: Most Lisp implementations include a primitive
called runtime that returns an integer that specifies
the amount of time the system has been running (measured,
for example, in microseconds). The following timed-prime-test
procedure, when called with an integern, prints n and checks
to see if n is prime. If n is prime, the procedure prints
three asterisks followed by the amount of time used in performing
the test.|#

(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time))))

(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))

#| Using this procedure, write a procedure search-for-primes
that checks the primality of consecutive odd integers in a
specified range. Use your procedure to find the three smallest
primes larger than 1000; larger than 10,000; larger than
100,000; larger than 1,000,000. Note the time needed to test
each prime. Since the testing algorithm has order of growth 
of Θ(√n), you should expect that testing for primes around
10,000 should take about √10 times as long as testing for
primes around 1000. Do your timing data bear this out?
How well do the data for 100,000 and 1,000,000 support
the Θ(√n) prediction? Is your result compatible with the notion
that programs on your machine run in time proportional to
the number of steps required for the computation?|#

#lang racket/base
(define (runtime) (current-inexact-milliseconds))

(define (square x) (* x x))

(define (smallest-divisor n)
  (find-divisor n 2))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n)
         n)
        ((divides? test-divisor n)
         test-divisor)
        (else (find-divisor
               n
               (+ test-divisor 1)))))

(define (divides? a b)
  (= (remainder b a) 0))

(define (prime? n)
  (= n (smallest-divisor n)))

(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
  (when (prime? n)
      (report-prime (- (runtime) start-time))))

(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))

(define (search-for-primes start end)
  (if (even? start)
      (search-for-primes (+ 1 start) end)
      (when (< start end)
             (timed-prime-test start)
                  (search-for-primes (+ 2 start) end))))

(search-for-primes 1000 1090)

(search-for-primes 10000 10090)

(search-for-primes 100000 100090)

(search-for-primes 1000000 1000090)

; Calculation results (I used the first five prime numbers):
; 
; 1009 *** 0.00048828125
; 1013 *** 0.00048828125
; 1019 *** 0.00048828125
; 1021 *** 0.000244140625
; 1031 *** 0.00048828125
; 
; 10007 *** 0.0009765625
; 10009 *** 0.001220703125
; 10037 *** 0.0009765625
; 10039 *** 0.0009765625
; 10061 *** 0.00048828125
; 
; 100003 *** 0.00244140625
; 100019 *** 0.002685546875
; 100043 *** 0.002685546875
; 100049 *** 0.002685546875
; 100057 *** 0.0029296875
; 
; 1000003 *** 0.0078125
; 1000033 *** 0.00830078125
; 1000037 *** 0.008544921875
; 1000039 *** 0.00830078125
; 1000081 *** 0.00830078125
; 
; Execution Time Analysis:
; 
; 1. For numbers around 1000:
;    - Average checking time: 0.000429 seconds
; 
; 2. For numbers around 10,000:
;    - Average checking time: 0.001030 seconds
;    - Time ratio compared to numbers around 1000: 2.40
; 
; 3. For numbers around 100,000:
;    - Average checking time: 0.002685 seconds
;    - Time ratio compared to numbers around 10,000: 2.61
; 
; 4. For numbers around 1,000,000:
;    - Average checking time: 0.008292 seconds
;    - Time ratio compared to numbers around 100,000: 3.09
; 
; Conclusion:
; 
; The execution time for checking the primality of numbers increases
; with the number size, but not strictly proportional to √10 ≈ 3.16.
; The time increases, and this growth is confirmed, especially for
; larger numbers.


#|Exercise 1.23: The smallest-divisor procedure shown at
the start of this section does lots of needless testing: After it
checks to see if the number is divisible by 2 there is no point
in checking to see if it is divisible by any larger even numbers.
This suggests that the values used for test-divisor
should not be 2, 3, 4, 5, 6, …, but rather 2, 3, 5, 7, 9, …
To implement this change, define a procedure next that returns 3
if its input is equal to 2 and otherwise returns its input plus 2.
Modify the smallest-divisor procedure to use (next test-divisor)
instead of (+ test-divisor 1).
With timed-prime-test incorporating this modified version of
smallest-divisor, run the test for each of the 12 primes found
in Exercise 1.22. Since this modification halves the number of
test steps, you should expect it to run about twice as fast.
Is this expectation confirmed? If not, what is the observed
ratio of the speeds of the two algorithms, and how do you 
explain the fact that it is different from 2?|#
    
; Solution:
#lang racket/base

(define (runtime) (current-inexact-milliseconds))

(define (square x) (* x x))

(define (smallest-divisor n)
  (find-divisor n 2))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n)
         n)
        ((divides? test-divisor n)
         test-divisor)
        (else (find-divisor
               n
               (next test-divisor)))))

(define (divides? a b)
  (= (remainder b a) 0))

(define (prime? n)
  (= n (smallest-divisor n)))

(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
  (when (prime? n)
      (report-prime (- (runtime) start-time))))

(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))

(define (search-for-primes start end)
  (if (even? start)
      (search-for-primes (+ 1 start) end)
      (when (< start end)
             (timed-prime-test start)
                  (search-for-primes (+ 2 start) end))))

(define (next i)
  (if (= i 2)
      3
      (+ i 2)))

; Calculation results (the first five prime numbers were taken):

; 1009 *** 0.000244140625
; 1013 *** 0.000244140625
; 1019 *** 0.000244140625
; 1021 *** 0.000244140625
; 1031 *** 0.000244140625

; 10007 *** 0.000732421875
; 10009 *** 0.000732421875
; 10037 *** 0.000732421875
; 10039 *** 0.00048828125
; 10061 *** 0.000732421875

; 100003 *** 0.001708984375
; 100019 *** 0.000732421875
; 100043 *** 0.0009765625
; 100049 *** 0.001708984375
; 100057 *** 0.00146484375

; 1000003 *** 0.005126953125
; 1000033 *** 0.00439453125
; 1000037 *** 0.002685546875
; 1000039 *** 0.0048828125
; 1000081 *** 0.0048828125

; Execution Time Analysis:

; 1. For numbers around 1000:
;    - Average checking time: 0.000244 seconds
;    - In the previous task: 0.000429 seconds
;    - Time ratio: 1.76

; 2. For numbers around 10,000:
;    - Average checking time: 0.000683 seconds
;    - In the previous task: 0.001030 seconds
;    - Time ratio: 1.51

; 3. For numbers around 100,000:
;    - Average checking time: 0.001458 seconds
;    - In the previous task: 0.002685 seconds
;    - Time ratio: 1.84

; 4. For numbers around 1,000,000:
;    - Average checking time: 0.004598 seconds
;    - In the previous task: 0.008292 seconds
;    - Time ratio: 1.80

; Conclusion:

; The optimization resulted in a significant reduction in
; the execution time of the prime-checking algorithm:

; 1. For numbers around 1000, time decreased by a factor of 1.76.
; 2. For numbers around 10,000, time decreased by a factor of 1.51.
; 3. For numbers around 100,000, time decreased by a factor of 1.84.
; 4. For numbers around 1,000,000, time decreased by a factor of 1.80.

; These results show that the modification led to a reduction in the number 
; of checking steps. Although a twofold speedup was expected, the actual 
; speedup ranges from 1.51 to 1.84 times. 

; The algorithmic reason why the improved algorithm, which halved the number 
; of steps, did not speed up the computations by 2 times is because we also 
; added some new computations for each step:

; - another function call (next function)
; - if
; - predicate (= n 2)
