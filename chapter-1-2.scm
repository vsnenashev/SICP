#| 1.2 Procedures and the Processes They Generate #|

#|Exercise 1.9: Each of the following two procedures defines a method
for adding two positive integers in terms of the procedures inc,
which increments its argument by 1, and dec, which decrements its argument by 1. |#
(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))

#|Using the substitution model, illustrate the process generated by each procedure
in evaluating (+ 4 5). Are these processes iterative or recursive? |#

;; Solution:

;;1. Recursive process:

(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9

;;This process is recursive because it computes through
;;recursive calls until it reaches the base case (when `a` becomes 0).

;;2. Iterative process:

(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9

#|This process is iterative because it computes in a loop, using
intermediate values (`a` decreases from 4 to 0, while `b` increases from 5 to 9).

Thus, the first procedure uses recursion to compute the sum,
while the second procedure uses iteration. |#


#|Exercise 1.10: The following procedure computes a mathematical function
called Ackermann’s function.|#
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))

;;What are the values of the following expressions?
(A 1 10)
(A 2 4)
(A 3 3)

;;Consider the following procedures, where A is the procedure defined above:

(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))

#| Give concise mathematical definitions for the functions computed by
the procedures f, g, and h for positive integer values of n.
For example, (k n) computes 5n^2.|#

;; Solution:
;;Computing (A 1 10):
(A 1 10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8)))
…
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
…
1024

;;Computing (A 2 4):
(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (A 0 (A 1 1))))
(A 1 (A 1 (* 2 (A 1 1))))
(A 1 (A 1 (* 2 2)))
(A 1 (A 1 4))
…
(A 1 16)
…
2 ^ 16 = 65536

;;Computing (A 3 3):
(A 3 3)
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
(A 2 (A 1 (A 2 1)))
(A 2 (A 1 2))
(A 2 4)
…
65536

;;Consider the following procedure:
(define (f n) (A 0 n))

;;Based on the definition of procedure A, substitute x = 0, y = n:
(define (A 0 n)
  (cond ((= n 0) 0)
        ((= 0 0) (* 2 n))
        ((= n 1) 2)
        (else (A (- 0 1) (A 0 (- n 1))))))

;;This procedure simplifies to:
(define (A 0 n)
  (* 2 n))

;;Thus, the procedure f can be written as: f(n) = 2n

;;Consider the procedure g:
(define (g n) (A 1 n))

;;We will proceed similarly. Substitute values:
(define (A 1 n)
  (cond ((= n 0) 0)
        ((= 1 0) (* 2 y))
        ((= n 1) 2)
        (else (A (- 1 1) (A 1 (- n 1))))))

;;Simplify:
(define (A 1 n)
  (cond ((= n 0) 0)
        ((= n 1) 2)
        (else (A 0 (A 1 (- n 1))))))

;;Considering the formula for f(n):
(define (A 1 n)
  (cond ((= n 0) 0)
        ((= n 1) 2)
        (else (* 2 (A 1 (- n 1))))))

;;The procedure can be written recursively: g(n) = 2 * g(n - 1) (except when n = 0).
;;Thus, the procedure g can be written as: g(n) = 0, if n = 0; g(n) = 2^n

;;Consider the procedure h:
(define (h n) (A 2 n))

;;Substitute and simplify:
(define (A 2 n)
  (cond ((= n 0) 0)
        ((= n 1) 2)
        (else (A 1 (A 2 (- n 1))))))

#|Considering the formula for g(n), the function can be written recursively
(again, except when n = 0): h(n) = 2^(h(n-1)). Thus, the procedure h can be
written as: h(n) = 0, if n = 0; h(n) = 2^(2^(2^…2^2)…), that is, 2 raised to
the power of 2, raised to the power of 2, and so on (n - 1) times.|#


#| Exercise 1.11: A function f is defined by the rule that 
f(n) = n, if n < 3, and f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3), if n ≥ 3.
Write a procedure that computes f by means of a recursive
process. Write a procedure that computes f by means of an iterative process. |#

;; Solution:
;;recursive process ver. 1
(define (f n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        ((= n 2) 2)
        (else (+ (f (- n 1))
                 (* 2 (f (- n 2)))
                 (* 3 (f (- n 3)))))))

;;ver. 2
(define (f n)
  (if (< n 3)
      n
      (+ (f (- n 1))
                 (* 2 (f (- n 2)))
                 (* 3 (f (- n 3))))))

;;iterative process
(define (f-iter n)
  (f-i 2 1 0 n))

(define (f-i a b c count)
  (if (= count 0)
      c
      (f-i (+ (* 3 c) (* 2 b) a)
           a
           b
           (- count 1))))


#| Exercise 1.12: The following pattern of numbers is called Pascal’s triangle.
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
. . .
The numbers at the edge of the triangle are all 1, and each number inside
the triangle is the sum of the two numbers above it. Write a procedure that
computes elements of Pascal’s triangle by means of a recursive process. |#

;; Solution:
(define (solution row n)
  (cond ((= row 1) 1)
        ((= n 1) 1)
        ((= n row) 1)
        (else (+ (solution (- row 1) (- n 1))
                 (solution (- row 1) n)))))


#|Exercise 1.13: Prove that Fib(n) is the closest integer to φ^n / √5,
where φ = (1 + √5) / 2. Hint: Let ψ = (1 − √5) / 2. Use induction
and the definition of the Fibonacci numbers (see Section 1.2.2) to prove
that Fib(n) = (φ^n − ψ^n) / √5.|#

#|Solution:
1. Base Case
For n = 0:  
Fib(0) = 0  
(φ^0 - ψ^0) / √5 = (1 - 1) / √5 = 0  

For n = 1:  
Fib(1) = 1  
(φ^1 - ψ^1) / √5 = (φ - ψ) / √5 =
= ((1 + √5)/2 - (1 - √5)/2) / √5 = √5 / √5 = 1  

2. Induction Hypothesis
Assume the formula holds for n = k and n = k+1:  
Fib(k) = (φ^k - ψ^k) / √5  
Fib(k+1) = (φ^(k+1) - ψ^(k+1)) / √5  

3. Induction Step
Show that the formula holds for n = k+2:  
Fib(k+2) = Fib(k+1) + Fib(k)  
Fib(k+2) = (φ^(k+1) - ψ^(k+1)) / √5 + (φ^k - ψ^k) / √5  
Fib(k+2) = (φ^(k+1) + φ^k - (ψ^(k+1) + ψ^k)) / √5  

Proving the properties of φ and ψ:
φ = (1 + √5) / 2
φ^2 = ((1 + √5) / 2)^2 = (1 + 2√5 + 5) / 4 =
= (6 + 2√5) / 4 = (3 + √5) / 2
φ + 1 = (1 + √5) / 2 + 1 = (3 + √5) / 2
Thus, φ^2 = φ + 1.  

Similarly for ψ:
Thus, ψ^2 = ψ + 1.  

Using these properties:  
φ^(k+2) = φ^(k+1) * φ = (φ + 1) * φ^k = φ^(k+1) + φ^k  
ψ^(k+2) = ψ^(k+1) * ψ = (ψ + 1) * ψ^k = ψ^(k+1) + ψ^k  

Thus,  
Fib(k+2) = (φ^(k+2) - ψ^(k+2)) / √5  

4. Conclusion
By induction, the formula Fib(n) = (φ^n - ψ^n) / √5 holds for all n.
Since |ψ| < 1, ψ^n approaches zero as n increases,
therefore Fib(n) approximates φ^n / √5, proving that Fib(n)
is the nearest integer to φ^n / √5.|#


#|Exercise 1.14: Draw the tree illustrating the process generated
by the count-change procedure of Section 1.2.2 in making change
for 11 cents. What are the orders of growth of the space
and number of steps used by this process as he amount to be changed increases?|#

;; Solution:
;; Simplified tree illustrating the process generated by the
;; count-change procedure from section 1.2.2 for exchanging 11 cents.

(cc 11 5)
├── (cc 11 4)
│   ├── (cc 11 3)
│   │   ├── (cc 11 2)
│   │   │   ├── (cc 11 1)
│   │   │   │   └── ...
│   │   │   │             ├── (cc 1 0) -> 0
│   │   │   │             └── (cc 0 1) -> 1
│   │   │   └── (cc 6 2)
│   │   │       ├── (cc 6 1)
│   │   │       │   └── ...
│   │   │       │             ├── (cc 1 0) -> 0
│   │   │       │             └── (cc 0 1) -> 1
│   │   │       └── (cc 1 2)
│   │   │           ├── (cc 1 1)
│   │   │           │   └── ...
│   │   │           │             ├── (cc 1 0) -> 0
│   │   │           │             └── (cc 0 1) -> 1
│   │   │           └── (cc -4 2) -> 0
│   │   └── (cc 1 3)
│   │       └── ...
│   │                 ├── (cc 1 0) -> 0
│   │                 └── (cc 0 1) -> 1
│   └── (cc -14 4) -> 0
└── (cc -39 5) -> 0

#| Growth Orders of Space

Since this is a recursive process, the order of
growth of space should be proportional to the depth of the tree.
Let's consider the growth orders for different numbers of coins
and try to understand the pattern. The longest series of calls
will occur when changing the amount n using only coins worth 1 cent.
The order of growth of space for (cc) will be R(n, 1) = Θ(n).
This can be seen in the example: |#

(cc n 1)
├── (cc n-1 1)
│   ├── (cc n-2 1)
│   │   └── ...
│   │             ├── (cc 0 1) -> 1
│   │             └── (cc 1 0) -> 0
│   └── (cc n-1 0) -> 0
└── (cc n 0) -> 0

#| The process is linear, and each node splits into two sub-steps,
but only the node with (cc n 1) will be deeper. All (cc n 0) are leaves of this tree.

When increasing the number of coins to two, it is no longer
a linear array but a two-dimensional one, as can be seen in the example: |#

(cc n 2)
├── (cc n 1)
│   └── ...
│             ├── (cc 0 1) -> 1
│             └── (cc 1 0) -> 0
├── (cc n-5 2)
│   └── ...
│             ├── (cc 0 1) -> 1
│             └── (cc 1 0) -> 0
├── (cc n-10 2)
│   └── ...
│             ├── (cc 0 1) -> 1
│             └── (cc 1 0) -> 0
├── ...
└── (cc neg-num 2) -> 0

#| The number of calls to (cc n 2) will equal the number of times 5 cents
can be subtracted from n plus one. And for each such call (amount),
we call the variant with only one coin. Thus, the growth will
already be quadratic R(n, 2) = Θ(n²).

Similarly, by increasing the number of coins, it can be seen that
for the case of five coins the answer will Θ(n^5), since each type of coin
adds a new degree to the growth.

Generalizing to the case of k coins, it can be proven that:
R(n, k) ≤ k * R(n-1, k) + O(1).|#


#|Exercise 1.15: The sine of an angle (specified in radians) can be
computed by making use of the approximation sin x ≈ x if x is
sufficiently small, and the trigonometric identity
sin(x) = 3sin(x / 3) − 4sin³(x / 3)
to reduce the size of the argument of sin. (For purposes of this exercise
an angle is considered “sufficiently small” if its magnitude is not
greater than 0.1 radians.) These ideas are incorporated in the
following procedures: |#

(define (cube x) (* x x x))

(define (p x) (- (* 3 x)
                 (* 4 (cube x))))

(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))

#| a. How many times is the procedure p applied when
(sine 12.15) is evaluated?

b. What is the order of growth in space and number of
steps (as a function of a) used by the process generated
by the sine procedure when (sine a) is evaluated?
|#

#|Solution:

a. The `sine` procedure divides the angle by 3 until it
becomes less than or equal to 0.1 radians. This occurs when:

12.15 / 3^n ≤ 0.1

Solving for n:

121.5 ≤ 3^n
n ≥ log(121.5) ≈ 5

The `p` procedure is called 5 times.

b. Orders of growth in terms of the number of steps
and memory used (as a function of a) for the process
generated by the `sine` procedure when computing `(sine a)`

The number of steps and memory used are proportional
to the depth of recursion, which is equal to log(a).

- Number of steps: Θ(log(a))
- Memory used: Θ(log(a)) |#


#|Exercise 1.16: Design a procedure that evolves an iterative
exponentiation process that uses successive squaring
and uses a logarithmic number of steps, as does fast-expt.
(Hint: Using the observation that ((bⁿ୵²)² = (b²)ⁿ୵², keep,
along with the exponent n and the base b, an additional
state variable a, and define the state transformation in such
a way that the product abⁿ is unchanged from state to state.
At the beginning of the process a is taken to be 1, and the
answer is given by the value of a at the end of the process.
In general, the technique of defining an invariant quantity
that remains unchanged from state to state is a powerful
way to think about the design of iterative algorithms.) |#

;; Solution:
(define (solution b n)
  (expt-iter 1 b n))

(define (expt-iter a b n)
  (cond ((= n 0) a)
        ((even? n) (expt-iter a (* b b) (/ n 2)))
        (else (expt-iter (* a b) b (- n 1)))))

(define (even? n)
  (= (remainder n 2) 0))


#|Exercise 1.17: The exponentiation algorithms in this section are
based on performing exponentiation by means of repeated multiplication.
In a similar way, one can perform integer multiplication by means of
repeated addition. The following multiplication procedure (in which
it is assumed that our language can only add, not multiply) is
analogous to the expt procedure: |#

(define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))

#| This algorithm takes a number of steps that is linear in b. Now
suppose we include, together with addition, operations double, which
doubles an integer, and halve, which divides an (even) integer by 2.
Using these, design a multiplication procedure analogous to fast-expt 
that uses a logarithmic number of steps.|#

;; Solution:
(define (fast-mul a b)
  (cond ((= b 0) 0)
        ((even? b) (double (fast-mul a (halve b))))
        (else (+ a (fast-mul a (- b 1))))))

(define (double x) (+ x x))

(define (halve x) (/ x 2))

;; halve 2nd version (if division is not available):
(define (halve x)
  (define (halve-i y z)
    (if (= y (double z))
        z
        (halve-i y (- z 1))))
  (halve-i x x))

#|Exercise 1.18: Using the results of Exercise 1.16 and Exercise 1.17,
devise a procedure that generates an iterative process for multiplying 
two integers in terms of adding, doubling, and halving and uses a
logarithmic number of steps.|#

;; Solution:
(define (double x) (+ x x))

(define (halve x) (/ x 2))

(define (mul-iter a b)
  (iter 0 a b))

(define (iter res a b)
  (cond ((= b 0) res)
        ((even? b) (iter res (double a) (halve b)))
        (else (iter (+ res a) a (- b 1)))))
